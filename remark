1、IoC：（控制反转）

AOP： 在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
依赖注入（Dependecy Injection）和控制反转（Inversion of Control）：是同一个概念，具体的讲：当某个角色需要另外一个角色协助的时候，
在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中创建被调用者的工作不再由调用者来完成，创建被调用者的工作
由spring来完成，然后注入调用者

反转指的是获取对象的方式发生了反转，以往对外部资源或对象的获取依赖于程序主动通过 new 引导，现在则是通过容器实现
依赖指的是应用程序依赖于 IOC 容器注入对象所需的外部资源

依赖注入的实现方式：
    a. 属性Setter方法注入
    b. 构造函数注入
    c. 基于注解的注入
    d. 静态/实例工厂方法注入

2、spring mvc 运行流程？

spring mvc 先将请求发送给 DispatcherServlet。
DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。
DispatcherServlet 再把请求提交到对应的 Controller。
Controller 进行业务逻辑处理后，会返回一个ModelAndView。
Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。
视图对象负责渲染返回给客户端。

3、判断对象是否可以被回收：

一般有两种方法来判断：
引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

4、interface / abstract class 的应用场合

interface应用场合:
A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

abstract class的应用场合:
一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：
A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能

5、mybatis缓存机制

MyBatis查询数据的顺序是：二级缓存   —> 一级缓存 —> 数据库

a. 一级缓存（也叫本地缓存）只是相对于同一个SqlSession而言，用于保存用户在一次会话过程中查询的结果
SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，
此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。

一级缓存默认是自动开启了，不允许开发人员进行关闭

b.二级缓存（全局缓存）是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用
同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域，所以对SqlSession是共享的

默认是没有开启的。需要手动配置开启二级缓存

6、三次握手的过程(seq 表示请求序列号，ack 表示确认序列号，SYN 和 ACK 为标志位。)
a. 第1次握手建立连接时，客户端向服务器发送SYN 报文（SYN=1, seq=x），并进入SYN_SENT 状态，等待服务器确认
b. 第2次握手实际上是分两部分来完成的，即 SYN+ACK（请求和确认）报文。
  1)服务器收到了客户端的请求，向客户端回复一个确认信息（ack=x+1）。
  2)服务器再向客户端发送一个 SYN 包（seq=y）建立连接的请求，此时服务器进入 SYN_RECV 状态，如图所示。
c.第3次握手，是客户端收到服务器的回复（SYN+ACK 报文）。此时客户端也要向服务器发送确认包（ACK）。此包发送完毕客户端和服务器进入ESTABLISHED状态，完成3次握手
连接建立后，客户端和服务器就可以开始进行数据传输了。

7、BIO、NIO、AIO 有什么区别？
  BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
  NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
  AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

8、双亲委派机制
加载阶段：
1）加载：查找并加载类的二进制字节流数据。
2）验证：保证被加载的类的正确性。
3）准备：为类的静态变量分配内存，并设置默认初始值。
4）解析：把类中的符号引用转换为直接引用。
5）初始化：为类的静态变量赋予正确的初始值。

加载器:
BootStrapClassLoader:加载jre/lib下的jdk的jar包，具有超级权限，是最顶级的类加载器；
ExtensionClassLoader:加载jre/lib/ext下的jar包，加载jdk的扩展程序包；
ApplicationClassLoader:加载当前应用classpath下的jar包或者class文件；
自定义ClassLoader：用户自定义的类加载器，一般是为了进行进程隔离，或者自己操纵字节码；

双亲委派机制描述:
某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

双亲委派优势:
1)、系统类防止内存中出现多份同样的字节码(防止重复加载同一个类)
2)、保证Java程序安全稳定运行

9、自增值保存在哪
1) MYISAM引擎的自增值保存在数据文件中
2) InnoDB的自增值保存在内存中,8.0版本中引入了自增值持久化的能力,如果发生重启,表的自增值可以恢复到重启之前的值

具体情况是:
1) 5.7及之前版本里,自增值保存在内存中,没有持久化,每次重启之后,第一次打开表时,都会去查找自增值的最大值max(id),然后将max(id)+1
   作为这个表的当前的自增值. 
   
   举例来说,如果当前数据行里的最大id是10,Auto_Increment=11,这是删除id=10的行,Auto_Increment还是11,如果马上重启实例,重启之后
   这个表的Auto_Increment就会变成10. 也就是说,重启之后会修改一个表的Auto_Increment值.
   
2) 在MySQL8.0版本,将自增值的变更记录存在了redo log中,重启的时候依靠redo log恢复重启之前的值.

